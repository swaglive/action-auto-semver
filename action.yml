name: Auto Semver
description: Auto generate semver
inputs:
  major_labels:
    description: labels indicate it would bump major version
    required: false
    default: major
  minor_labels:
    description: labels indicate it would bump minor version
    required: false
    default: minor
  patch_labels:
    description: labels indicate it would bump patch version
    required: false
    default: patch
  token:
    description: the repo's Github token that use the action
    required: false
    default: ${{ github.token }}
  default_previous_tag_name:
    description: the default previous tag if there no release tag found
    required: false
    default: "0.0.0"
runs:
  using: composite
  steps:
    - id: last_tag
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        gh version
        # prevent there are release title contain space, print count from last column -1
        # gh release list would show following
        # <release title> Latest (tag_name) time

        tag_name=$(gh release list -L 1 | awk '{print $(NF - 1)}')
        [[ $tag_name == '' ]] && tag_name='${{ inputs.default_previous_tag_name }}'
        echo "::set-output name=tag_name::$tag_name"
    - id: get_labels
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        commit=${{ github.sha }}
        # this would return multiple labels, since pull request may attach multiple labels and one of the label may indicate the predefined semver label
        # try to match  mergeCommit by `$commit`, it should exist when trigger is `on.push master`  
        # TODO: maybe handle cannot find the PR's labels by current commit, if the trigger is not from PR merged (like on.push.tags)
        labels=$(gh pr list --limit 1 --state merged --search $commit --json  mergeCommit,labels \
        | jq -r '.[0].labels | select(length > 0) | map(.name) | join(",")')
        echo "::set-output name=current_labels::"
        echo "::set-output name=current_labels::$labels"
    - id: calculate-semver
      shell: python
      run: |
        import re;

        labels = '${{ steps.get_labels.outputs.current_labels }}'
        input_major_labels = '${{ inputs.major_labels }}'
        input_minor_labels = '${{ inputs.minor_labels }}'
        input_patch_labels = '${{ inputs.patch_labels }}'

        labels = set(labels.split(','))

        ## REF: https://github.com/swaglive/action-semver/blob/main/action.yaml#L11
        version_regexp = re.compile('^v?(?P<major>[0-9]+)(?:\.(?P<minor>[0-9]+))?(?:\.(?P<patch>[0-9]+))?(?:\-(?P<prerelease>[\w-]+))?(?:\+(?P<build>[\w-]+))?$')

        prev = '${{ steps.last_tag.outputs.tag_name }}'
        previous_versions = version_regexp.match(prev).groupdict()

        major = int(previous_versions['major'])
        minor = int(previous_versions['minor'])
        patch = int(previous_versions['patch'])

        bump_major = len (set(input_major_labels.split(',')).intersection(labels)) > 0
        bump_minor = len (set(input_minor_labels.split(',')).intersection(labels)) > 0
        bump_patch = len (set(input_patch_labels.split(',')).intersection(labels)) > 0

        if bump_major:
            major = major + 1;
            minor = 0;
            patch = 0;
        elif bump_minor:
            patch = 0;
            minor = minor + 1;
        elif bump_patch:
            patch = patch + 1;
        # if not bump any of version, it return previous one
        version = f'{major}.{minor}.{patch}'
        print(f'::set-output name=version::{version}')
        print(f'::set-output name=major::{major}')
        print(f'::set-output name=minor::{minor}')
        print(f'::set-output name=patch::{patch}')
